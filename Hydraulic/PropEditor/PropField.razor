@using System.Reflection;
<td>
    <span>@StringCut(prop.Name)</span>
</td>
@if (prop.PropertyType.IsEnum)
{
    <td>
        <select @onchange="(e) => OnValueChange.InvokeAsync(e.Value.ToString())">

            @foreach (var value in Enum.GetValues(prop.PropertyType))
            {
                if ((int)value == (int)this.value)
                {
                    <option selected>@value</option>
                }
                else
                {
                    <option>@value</option>
                }
            }

        </select>
    </td>
}
else if (prop.PropertyType == typeof(int))
{
    <td><input type="number" value="@value.ToString()" @onchange="(e) => OnValueChange.InvokeAsync(e.Value.ToString())"></td>
}

else if (prop.PropertyType == typeof(float))
{
    <td><input type=number step=any value="@value.ToString()" @onchange="(e) => OnValueChange.InvokeAsync(e.Value.ToString())"></td>
}

@code {

    [Parameter]
    public EventCallback<string> OnValueChange { get; set; }

    [Parameter]
    public PropertyInfo prop { get; set; }

    [Parameter]
    public object value { get; set; }

    protected override void OnInitialized()
    {
        base.OnInitialized();
    }

    private string StringCut(string newString)
    {
        int pFrom = newString.IndexOf("<") + 1;
        int pTo = newString.LastIndexOf(">");

        if (pFrom == -1 || pTo == -1)
        {
            Console.Error.WriteLine("Failed to convert the string when reflecting on the properties");
        }

        string result = newString.Substring(pFrom, pTo - pFrom);
        //Console.WriteLine("input " + newString);
        return result;
    }

}
